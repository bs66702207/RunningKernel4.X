P531:是mutex使用方式的小结
P544:是读写锁的控制逻辑小结
Chapter 4.6 RCU read-copy-update
    读写锁的缺点，允许多个读者存在，但是不允许读者和写者同时存在。
    那么RCU机制要实现的目标是，希望读者线程没有同步开销，或者说同步开销变得很小，甚至可以忽略不计，不需要额外的锁，不需要使用原子操作指令和内存屏障，即可畅通无阻的访问；
而把需要同步的任务交给写者线程，写着线程等待所有读者线程完成后才会把旧数据销毁。在RCU中，如果有多个写着同时存在，那么需要额外的保护机制。
    RCU机制的原理可以概括为RCU记录了所有指向共享数据的指针的使用者，当要修改该共享数据时，首先创建一个副本，在副本中修改。所有读访问线程都离开临界区之后，指针指向新的修改后
副本的指针，并且删除旧数据。
    RCU的一个重要的应用场景是链表，比如在读者遍历链表时，假设另外一个线程删除了一个节点。删除线程会把这个节点从链表中移出，但不会直接销毁它。RCU会等到所有读者线程读取完成后，
才会销毁这个节点。
    RCU提供的接口如下。
rcu_read_lock()/rcu_read_unlock(): //组成一个RCU读临界。
rcu_dereference(): //用于获取被RCU保护的指针(RCU protected pointer)，读者线程要访问RCU保护的共享数据，需要使用该函数创建一个新指针，并且指向RCU被保护的指针。
rcu_assign_pointer(): //通常用在写者线程。在写者线程完成新数据的修改后，调用该接口可以让被RCU保护的指针指向新创建的数据，用RCU的术语是发布(Publish)了更新后的数据
synchronize_rcu(): //同步等待所有现存的读访问完成。
call_rcu(): //注册一个回调函数，当所有现存的读访问完成后，调用这个回调函数销毁旧数据。
